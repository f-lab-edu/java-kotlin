# 개인 독후감

## Taek
### 느낀 점

해당 장에서는 재사용성의 중요성에 대해서 강조하고 있다. 하지만 무조건적으로 재사용을 하는게 아니라 하지 말아야할 때를 해야할 때를 단일 책임 원칙을 활용하여 예시를 들어줬던 부분이 인상깊었다. Item 20번의 `일반적인 알고리즘을 반복해서 구현하지 말라`에서 1. 표준 라이브러리 살펴보기 2. 나만의 유틸리티 구현하기 파트에서 당연하지만 다시 한번 짚어보는 시간이 되었다.

또한, type-safe하게 개발하기 위해서 제네릭을 사용하거나 제네릭을 제한하는 방법을 안내하고 있다.

그 외 마지막 Item에서는 코틀린이 굉장히 범용적인 언어임을 나타내고 있고, 비슷한 느낌(Full-Stack)으로 JavaScript 언어가 떠올랐고, 두 언어의 차이에 대해서는 차차 찾아보고 학습할 예정이다.

## Charles

 재사용이라는 주제를 충분히 다루지 못한 것 같아 아쉽다. 분량에 비해 너무 큰 주제를
잡은 것 같다. 재사용 단위와 재사용성을 저해하는 요소에 대해 직관적으로 설명하는 편이
더 좋았을 것 같다. 친절하게 설명하려 하다 보니 개별 사례에 치우친 것 같다.
 이런 류의 책에서 쉽게 발견되는 것인데 다수의 독자들을 대상으로 하다보니 깊은 내용을
다루지 못한다는 느낌이다. 독자들이 내용의 중요성보다 이해했다는 만족감을 바라다보니
이런 책들이 선택된다고 생각된다. 제네릭 타입 부분에서는 최소한 Category Theory 
정도는 소개해 주었으면 좋았을텐데...

## Kuma
첫 회사부터 지속적으로 리마인드 되는 재사용성에 대해 말하는 장이었다. 
새롭게 보게 된 몇몇 기술에 대한 설명에 대한 설명이 잘 되어 있어 이해는 쉬웠지만, 해당 기술들이 재사용성에 도움을 주는지 감은 안 온다.
이건 코틀린 숙달도가 낮아서 그런 거라 생각돼 계속 언어를 익히는 과정이 필요하다고 본다.

매 장 읽을 때마다 드는 생각이지만 정답은 없는 것 같다.
주제는 재사용성이지만, 언제나 재사용성을 위해 공통 분모를 찾아서 분리하고 관리하는 과정이 오히려 비효율적일 때도 있다.
수많은 주장 중 하나를 진리처럼 받들어 상황이나 프로젝트 성격을 고려하지 않은 채 무조건 적용만 하려는 행동을 지양하려 한다.

## Olive
사실 결론부터 말하자면, 책에서 어떤말을 하고자하는지 잘 모르겠다. 더 정확히는 주제와 아이템이 얼라인이 안맞는 것들이 몇몇개 들어있는 것 같다.
그리고 재사용성이라는 주제에 대해서 몇몇 아이템들은 너무 특정 케이스들에 대한 이야기를 다루고 끝나고, 몇몇 아이템들은 
그냥 너무 추상적으로 뭉뚱그려서 당연한 이야기를 하고 끝마치는 것 같은 느낌을 받았다. 그리고 이건 Charles께서 지난번에 말씀해주신 것 때문인지 코틀린에 대한 이해가 부족해서인지 몰라도, 예시가 좀
직관적이지 못한것 같아 조금 아쉬움이 남는다.

물론, 이 책이 "이펙티브 코틀린"이고 리팩터링이나 객체지향 등과 같은 주제를 다루는 책만큼 조금 더 일반적인 범주의 재사용성 측면에서 이야기를 하기를 바란 것은 아니지만,
그렇다고해도 가려운 부분을 충분히 긁어주지 못한 아쉬움이 남는다.

그리고 제네릭과 관련된 챕터는 "이펙티브 자바"에서 처럼 별도의 챕터로 분리해서 이야기를 진행해도 좋을 것 같았는데, 전반적인 챕터의 구성을 보니 "이펙티브 자바"와
"이펙티브 코틀린"이 서로 어느정도 공통된 이야기를 하고 있지만, 구성이 다르다는 것을 알게되었다. "이펙티브 자바"에서 처럼 특정 기술적인 부분을 묶어서 챕터를 구성한 것이 아니라,
개발자의 행동양식들과 같은 주제로 챕터를 구성하다보니까, 비슷한 특징을 가진 서로다른 요소들을 연결해서 볼 수 있다는 장점이 있지만, 단점은
각각의 요소들을 설명하다만 듯한 느낌이 든다. 즉, 뒤에 무슨 이야기가 더 나와야할 것 같은데 그러다 말고 뚝 끊어서 맥이 빠지는 느낌이다.

책에 대해서 너무 비판만 한 것 같은데.. 그래도 책에서 왜 "재사용성"이 중요한지에 대해서 언급한 부분들에 대해서는 대체로 동의하는 편이다.
 

---

# 토론 주제 

## Kotlin으로 풀스택 개발하기 vs 백엔드, 프론트 분리하여 개발하기

Olive : 생산성 문제, 이점들을 커버할 만큼의 장점이 있는지를 정확하게 따져봐야할 것 같다.
Kuma : front가 back 보다 빠르게 발전하기 때문에 코틀린이 경쟁력이 있을지에 대한 의문이 있다.
charles : 개발자 풀 문제, 트러블 슈팅할 수 있는 레벨이 되기는 힘들 것 같다. 현실적으로는 힘들 것 같다.

## 재사용성을 저해하는 것들은 무엇이 있을까?

* 재사용성이 필요할까?

olive : 상황에 따라서 다를 것 같다. 재사용성이 떨어진다는 건 중복이 많이 발생할 수 있다는 관점에서 봤을 때, => 복붙 

charles : 중복이 발생할 수록 재사용성이 올라간다.

Kuma : 어쩔 수 없이 재사용성을 침해하면서 코드를 작성할 때가 있는 것 같다. ex) 단발성 이벤트 같은 경우 실제 베이스가 된 실제 서비스에서 필요가 없는 경우가 있다. 예를들어 3일만 진행하는 이벤트, 기존에 있는 로직을 가져오다보니 유지보수 측면에서 안좋았다.

charles : 재사용에 대해서 명확하게, 로직이 같다고 같은 건 아니다. A, B가 같은 동작을 한다고 같은 건 아니다. Kuma님의 예제는 2개의 knowledge가 있다. kuma님의 예제 접근 방법이 올바른 방법이다.

kuma : 동작과 기능이 똑같다면 재사용을 할 수 밖에 없지 않나

charles : 20%의 코드가 80%의 성능을 발휘한다. -> 컴퓨터 공학에서는 함수 호출의 비용을 '0'로 가정한다. 재귀도 같은데, 현실에서 재귀를 하고 20%에 해당된다면 성능이 많이 낭비가 된다. 구조적으로는 좋지만, 20%의 코드에 해당되면 루프로 바꿔야한다.

### Q. 언제부터 재사용성에 대해서 관심이 갖게 되었을까?

제일 처음의 컴퓨터 -> 애니악

애니악은 미사일 궤도를 계산하기 위한 용도로 나왔음.

각각 컴파일을 한 다음 링크라는 것을 한게 C언어

큰 프로그램을 만들 때 생기는 문제를 해결하기 위해서 재사용성에 대해서 관심을 가지게 되었음

### Q. 파일을 왜 나누는것이 왜 중요할까?

컴파일 타임이 굉장히 오래걸린다.

파일이 커지면, 연산을 해야한다. 컴파일 타임에 앞에서부터 실행하는게 아니라 jump 등 에 대한 연산도 필요하기 때문에 현재 위치에서 offset 계산을 하려면 뒤를 읽어야지 어디로 jump할 수 있는지 address를 알 수 있다.

결론적으로 jump 등과 같은 것들에 의해서 컴파일 타임이 결정된다. 이러한 것들을 해결하기 위해서 파일을 나눈다.

프로그램이 커지면 재사용성이 필요하고, 작으면 필요없다.


## Re) 재사용성을 저해하는 것들은 무엇이 있을까?

olive : SOLID에서 SRP라는 요소가 있는데, 역할과 책임이 잘분리가 되어 있어야하고 공통적인 요소를 잘뽑아낼 수 있어야하는데 예를들어 하나의 메소드가 너무 많은 책임을 가지고 있을 때, 재사용성을 저해한다고 생각한다.

그렇다면 책임을 분리를 하면, 재사용성이 올라가는가?

kuma : 제대로 된 기획이 이루어지지 않은채 진행이 되거나, 변경이 많이 되는 구조라면 재사용성이 저해된다고 생각한다.

charles : 공학적인 측면) 컴퓨터 사이언스에서 풀고 싶어하는 제1문제는 무엇일까?? -> P-NP 문제, 복잡성을 푸는 것이 공학이 하는 것이다.
복잡성이란 A가 증가할 때, B가 선형이상으로 증가할 때 복잡성이 증가한다고 정의했다.

복잡성이란 왜 나오는 것인가?
=> 의존성. 의존에 의해서 복잡성이 발생한다. 알고리즘이 어디에 의존하냐에 따라서 그래프의 모양이 다르다.

의존성이 재사용성과 어떤 연관이 있는가?
=> A함수가 B를 사용하는 것과, A함수가 C함수를 사용한다고 했을 때, 재사용한다고 정의한다.
=> A는 B와 C에 의존한다. 
=> 의존성 다음이 SOLID 
=> 결론적으로, `의존성이 올바르지 않으면 재사용성을 저해한다.`

코틀린의 또 다른 장점) 유비쿼터스 언어로 쓸만한 언어인 것 같다. 아이디어를 표현해야하는데 예전에는 UML, ER다이어그램으로 표현했지만, java로 하면 굉장히 번거롭고 타이핑이 많아서 머릿속의 속도를 못따라간다. 하지만 코트린으로 표현하면 좋다. 따라서 Front, Back 을 개발할 때에도 아이디어 단계부터 재사용이 가능해서 좋음

SOLID가 나중에는 필요가 없다. -> 비공학적인 개발자들을 위한 내용

리스코프 치환 원칙에 따라 개발을 했는데, 왜 문제가 발생하는지?