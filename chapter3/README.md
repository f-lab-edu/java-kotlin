# 요약
## 3장 재사용성

## Item 19 knowledge를 반복하여 사용하지 말라

"프로젝트에서 이미 있던 코드를 복사해서 붙여넣고 있다면, 무언가가 잘못된 것이다."
* knowledge : 의도적인 정보
* Don't Repeat Yourself(DRY) = WET 안티패턴

### knowledge

프로그래밍에서 knowledge는 넓은 의미로 '의도적인 정보'를 뜻한다.

중요한 2가지 knowledge
* 로직(logic) : 프로그램이 어떠한 식으로 동작하는지와 프로그램이 어떻게 보이는지
* 공통 알고리즘 : 원하는 동작을 하기 위한 알고리즘

### 모든 것은 변화한다

knowledge가 계속해서 변화하는 이유

* 회사가 사용자의 요구 또는 습관을 더 많이 알게 되었다.
* 디자인 표준이 변화했다.
* 플랫폼, 라이브러리, 도구 등이 변화해서 이에 대응해야 한다.

Knowledge 반복의 단점

* 프로젝트의 확장성을 막고, 쉽게 깨지게 만든다.
=>(대안) 하이버네이트와 같은 ORM 익스포즈드와 같은 DAO

### 언제 코드를 반복해도 될까?

knowledge 반복을 줄이면 안 되는 상황도 있다.
ex) 독립적인 2개의 안드로이드 애플리케이션을 만들 때, 빌드 도구 설정이 비슷할 것이므로, 이를 추출해서 knowledge 반복을 줄일 수 있다고 생각할 수 있다.
하지만 두 애플리케이션은 독립적이므로 구성 변경이 일부 필요할 수도 있다. 한 애플리케이션 쪽의 구성만 변경해야 한다면 문제가 된다.


### 단일 책임 원칙

코드를 추출해도 되는지를 확인할 수 있는 원칙
(클래스를 변경하는 이유는 단 한가지여야 한다)

단일 책임 원칙은 2가지 사실을 알려준다.
* 서로 다른 곳에서 사용하는 knowledge는 독립적으로 변경할 가능성이 많다.
* 다른 knowledge는 분리해 두는 것이 좋다. 그렇지 않으면, 재사용해서는 안 되는 부분을 재사용하려는 유혹이 발생할 수 있다.

## Item 20 일반적인 알고리즘을 반복해서 구현하지 말라

이미 있는 것을 활용하면, 단순하게 코드가 짧아진다는 것 이외에도 다양한 장점이 있다.
* 코드 작성 속도가 빨라진다.
* 구현을 따로 읽지 않아도, 함수의 이름 등만 보고도 무엇을 하는지 확실하게 알 수 있다.
* 직업 구현할 때 발생할 수 있는 실수를 줄일 수 있다.
* 제작자들이 한 번만 최적화하면, 이러한 함수를 활용하는 모든 곳이 최적화의 혜택을 받을 수 있다.

### 표준 라이브러리 살펴보기

가장 대표적인 라이브러리 : stdlib
=> 확장 함수를 활용해서 만들어진 굉장히 거대한 유틸리티 라이브러리

## Item 21 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라
코틀린은 코드 재사용과 관련하여 프로퍼티 위임이라는 새로운 기능을 제공한다.

* 지연 프로퍼티 : lazy 프로퍼티는 이후에 처음 사용하는 요청이 들어올 때 초기화되는 프로퍼티를 의미한다.

코틀린에서 프로퍼티 위임을 사용하면 간단하고 type-safe하게 구현할 수 있다.

코틀린 stdlib의 다음과 같은 프로퍼티 델리게이터를 알아 두면 좋다.

* lazy
* Delegates.observable
* Delegates.vetoable
* Delegates.notNull

## Item 22 일반적인 알고리즘을 구현할 때 제네릭을 사용하라

* 제네릭 함수 : 타입 아규먼트를 사용하는 함수

제네릭은 List<String>, Set<User> 처럼 구체적인 타입으로 컬렉션을 만들 수 있게 클래스와 인터페이스에 도입된 기능이다.
이러한 타입 정보 덕분에 MutableList<Int> 에 안전하게 Int를 추가할 수 있습니다.

### 제네릭 제한
타입 파라미터의 중요한 기능 중 하나는 구체적인 타입의 서브타입만 사용하게 타입을 제한하는 것이다.

## Item 23 타입 파라미터의 섀도잉을 피하라
타입 파라미터 섀도잉을 피해라, 타입 파라미터 섀도잉이 발생한 코드는 이해하기 어려울 수 있다.

## Item 24 제네릭 타입과 variance 한정자를 활용하라
코틀린은 타입 아규먼트의 관계에 제약을 걸 수 있는 굉장히 강력한 제네릭 기능을 제공한다. 이러한 기능으로 제네릭 객체를 연산할 때 굉장히 다양한 지원을 받을 수 있다.

## Item 25 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라

### 풀스택 개발
* 코틀린이 자바스크립트로 컴파일 될 수 있다는 점때문에 웹 백엔드와 프런트엔드를 모두 만들 수 있다.

### 모바일 개발
* 코틀린의 멀티 플랫폼 기능을 활용하면, 로직을 한 번만 구현하고, 두 플랫폼에서 이를 재사용할 수 있다.

### 라이브러리
* 플랫폼에 크게 의존하지 않는다는 점은 공통 모듈을 JVM, 자바스크립트, 네이티브 환경에서 작동하는 모든 언어에서 활용할 수 있다는 의미이다.


# 개인 독후감

## Taek
### 느낀 점

해당 장에서는 재사용성의 중요성에 대해서 강조하고 있다. 하지만 무조건적으로 재사용을 하는게 아니라 하지 말아야할 때를 해야할 때를 단일 책임 원칙을 활용하여 예시를 들어줬던 부분이 인상깊었다. Item 20번의 `일반적인 알고리즘을 반복해서 구현하지 말라`에서 1. 표준 라이브러리 살펴보기 2. 나만의 유틸리티 구현하기 파트에서 당연하지만 다시 한번 짚어보는 시간이 되었다.

또한, type-safe하게 개발하기 위해서 제네릭을 사용하거나 제네릭을 제한하는 방법을 안내하고 있다.

그 외 마지막 Item에서는 코틀린이 굉장히 범용적인 언어임을 나타내고 있고, 비슷한 느낌(Full-Stack)으로 JavaScript 언어가 떠올랐고, 두 언어의 차이에 대해서는 차차 찾아보고 학습할 예정이다.

## Charles

 재사용이라는 주제를 충분히 다루지 못한 것 같아 아쉽다. 분량에 비해 너무 큰 주제를
잡은 것 같다. 재사용 단위와 재사용성을 저해하는 요소에 대해 직관적으로 설명하는 편이
더 좋았을 것 같다. 친절하게 설명하려 하다 보니 개별 사례에 치우친 것 같다.
 이런 류의 책에서 쉽게 발견되는 것인데 다수의 독자들을 대상으로 하다보니 깊은 내용을
다루지 못한다는 느낌이다. 독자들이 내용의 중요성보다 이해했다는 만족감을 바라다보니
이런 책들이 선택된다고 생각된다. 제네릭 타입 부분에서는 최소한 Category Theory 
정도는 소개해 주었으면 좋았을텐데...

## Kuma
첫 회사부터 지속적으로 리마인드 되는 재사용성에 대해 말하는 장이었다. 
새롭게 보게 된 몇몇 기술에 대한 설명에 대한 설명이 잘 되어 있어 이해는 쉬웠지만, 해당 기술들이 재사용성에 도움을 주는지 감은 안 온다.
이건 코틀린 숙달도가 낮아서 그런 거라 생각돼 계속 언어를 익히는 과정이 필요하다고 본다.

매 장 읽을 때마다 드는 생각이지만 정답은 없는 것 같다.
주제는 재사용성이지만, 언제나 재사용성을 위해 공통 분모를 찾아서 분리하고 관리하는 과정이 오히려 비효율적일 때도 있다.
수많은 주장 중 하나를 진리처럼 받들어 상황이나 프로젝트 성격을 고려하지 않은 채 무조건 적용만 하려는 행동을 지양하려 한다.

## Olive
사실 결론부터 말하자면, 책에서 어떤말을 하고자하는지 잘 모르겠다. 더 정확히는 주제와 아이템이 얼라인이 안맞는 것들이 몇몇개 들어있는 것 같다.
그리고 재사용성이라는 주제에 대해서 몇몇 아이템들은 너무 특정 케이스들에 대한 이야기를 다루고 끝나고, 몇몇 아이템들은 
그냥 너무 추상적으로 뭉뚱그려서 당연한 이야기를 하고 끝마치는 것 같은 느낌을 받았다. 그리고 이건 Charles께서 지난번에 말씀해주신 것 때문인지 코틀린에 대한 이해가 부족해서인지 몰라도, 예시가 좀
직관적이지 못한것 같아 조금 아쉬움이 남는다.

물론, 이 책이 "이펙티브 코틀린"이고 리팩터링이나 객체지향 등과 같은 주제를 다루는 책만큼 조금 더 일반적인 범주의 재사용성 측면에서 이야기를 하기를 바란 것은 아니지만,
그렇다고해도 가려운 부분을 충분히 긁어주지 못한 아쉬움이 남는다.

그리고 제네릭과 관련된 챕터는 "이펙티브 자바"에서 처럼 별도의 챕터로 분리해서 이야기를 진행해도 좋을 것 같았는데, 전반적인 챕터의 구성을 보니 "이펙티브 자바"와
"이펙티브 코틀린"이 서로 어느정도 공통된 이야기를 하고 있지만, 구성이 다르다는 것을 알게되었다. "이펙티브 자바"에서 처럼 특정 기술적인 부분을 묶어서 챕터를 구성한 것이 아니라,
개발자의 행동양식들과 같은 주제로 챕터를 구성하다보니까, 비슷한 특징을 가진 서로다른 요소들을 연결해서 볼 수 있다는 장점이 있지만, 단점은
각각의 요소들을 설명하다만 듯한 느낌이 든다. 즉, 뒤에 무슨 이야기가 더 나와야할 것 같은데 그러다 말고 뚝 끊어서 맥이 빠지는 느낌이다.

책에 대해서 너무 비판만 한 것 같은데.. 그래도 책에서 왜 "재사용성"이 중요한지에 대해서 언급한 부분들에 대해서는 대체로 동의하는 편이다.
 

---

# 토론 주제 

## Kotlin으로 풀스택 개발하기 vs 백엔드, 프론트 분리하여 개발하기

Olive : 생산성 문제, 이점들을 커버할 만큼의 장점이 있는지를 정확하게 따져봐야할 것 같다.
Kuma : front가 back 보다 빠르게 발전하기 때문에 코틀린이 경쟁력이 있을지에 대한 의문이 있다.
charles : 개발자 풀 문제, 트러블 슈팅할 수 있는 레벨이 되기는 힘들 것 같다. 현실적으로는 힘들 것 같다.

## 재사용성을 저해하는 것들은 무엇이 있을까?

* 재사용성이 필요할까?

olive : 상황에 따라서 다를 것 같다. 재사용성이 떨어진다는 건 중복이 많이 발생할 수 있다는 관점에서 봤을 때, => 복붙 

charles : 중복이 발생할 수록 재사용성이 올라간다.

Kuma : 어쩔 수 없이 재사용성을 침해하면서 코드를 작성할 때가 있는 것 같다. ex) 단발성 이벤트 같은 경우 실제 베이스가 된 실제 서비스에서 필요가 없는 경우가 있다. 예를들어 3일만 진행하는 이벤트, 기존에 있는 로직을 가져오다보니 유지보수 측면에서 안좋았다.

charles : 재사용에 대해서 명확하게, 로직이 같다고 같은 건 아니다. A, B가 같은 동작을 한다고 같은 건 아니다. Kuma님의 예제는 2개의 knowledge가 있다. kuma님의 예제 접근 방법이 올바른 방법이다.

kuma : 동작과 기능이 똑같다면 재사용을 할 수 밖에 없지 않나

charles : 20%의 코드가 80%의 성능을 발휘한다. -> 컴퓨터 공학에서는 함수 호출의 비용을 '0'로 가정한다. 재귀도 같은데, 현실에서 재귀를 하고 20%에 해당된다면 성능이 많이 낭비가 된다. 구조적으로는 좋지만, 20%의 코드에 해당되면 루프로 바꿔야한다.

### Q. 언제부터 재사용성에 대해서 관심이 갖게 되었을까?

제일 처음의 컴퓨터 -> 애니악

애니악은 미사일 궤도를 계산하기 위한 용도로 나왔음.

각각 컴파일을 한 다음 링크라는 것을 한게 C언어

큰 프로그램을 만들 때 생기는 문제를 해결하기 위해서 재사용성에 대해서 관심을 가지게 되었음

### Q. 파일을 왜 나누는것이 왜 중요할까?

컴파일 타임이 굉장히 오래걸린다.

파일이 커지면, 연산을 해야한다. 컴파일 타임에 앞에서부터 실행하는게 아니라 jump 등 에 대한 연산도 필요하기 때문에 현재 위치에서 offset 계산을 하려면 뒤를 읽어야지 어디로 jump할 수 있는지 address를 알 수 있다.

결론적으로 jump 등과 같은 것들에 의해서 컴파일 타임이 결정된다. 이러한 것들을 해결하기 위해서 파일을 나눈다.

프로그램이 커지면 재사용성이 필요하고, 작으면 필요없다.


## Re) 재사용성을 저해하는 것들은 무엇이 있을까?

olive : SOLID에서 SRP라는 요소가 있는데, 역할과 책임이 잘분리가 되어 있어야하고 공통적인 요소를 잘뽑아낼 수 있어야하는데 예를들어 하나의 메소드가 너무 많은 책임을 가지고 있을 때, 재사용성을 저해한다고 생각한다.

그렇다면 책임을 분리를 하면, 재사용성이 올라가는가?

kuma : 제대로 된 기획이 이루어지지 않은채 진행이 되거나, 변경이 많이 되는 구조라면 재사용성이 저해된다고 생각한다.

charles : 공학적인 측면) 컴퓨터 사이언스에서 풀고 싶어하는 제1문제는 무엇일까?? -> P-NP 문제, 복잡성을 푸는 것이 공학이 하는 것이다.
복잡성이란 A가 증가할 때, B가 선형이상으로 증가할 때 복잡성이 증가한다고 정의했다.

복잡성이란 왜 나오는 것인가?
=> 의존성. 의존에 의해서 복잡성이 발생한다. 알고리즘이 어디에 의존하냐에 따라서 그래프의 모양이 다르다.

의존성이 재사용성과 어떤 연관이 있는가?
=> A함수가 B를 사용하는 것과, A함수가 C함수를 사용한다고 했을 때, 재사용한다고 정의한다.
=> A는 B와 C에 의존한다. 
=> 의존성 다음이 SOLID 
=> 결론적으로, `의존성이 올바르지 않으면 재사용성을 저해한다.`

코틀린의 또 다른 장점) 유비쿼터스 언어로 쓸만한 언어인 것 같다. 아이디어를 표현해야하는데 예전에는 UML, ER다이어그램으로 표현했지만, java로 하면 굉장히 번거롭고 타이핑이 많아서 머릿속의 속도를 못따라간다. 하지만 코트린으로 표현하면 좋다. 따라서 Front, Back 을 개발할 때에도 아이디어 단계부터 재사용이 가능해서 좋음

SOLID가 나중에는 필요가 없다. -> 비공학적인 개발자들을 위한 내용

리스코프 치환 원칙에 따라 개발을 했는데, 왜 문제가 발생하는지?