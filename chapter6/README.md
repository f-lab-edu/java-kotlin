# 요약
## 6장 클래스 설계

## 아이템36 - 상속보다는 컴포지션을 사용하라
 컴포지션은 번거롭지만 일반적으로 상속을 사용하는 것보다 좋습니다. 리스코프 치환
원칙을 만족하는 경우에만 상속을 사용해야 합니다. 상속은 다음 문제를 가지고 있습니다.
- 클래스에만 적용할 수 있습니다.
- 클래스의 모두를 재사용합니다.
- 이해하기 어렵습니다.
- 캡슐화를 망가뜨립니다.

## 아이템37 - 데이터 집합 표현에 data 한정자를 사용하라
 데이타 묶음에 data class를 사용하는 것이 튜플보다 장점이 많습니다.
- 리턴 타입이 명확하고, 전달하기 쉽습니다.

## 아이템38 - 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라
 다른 언어에서 사용하는 경우가 아니라면 함수 타입을 사용하는 것이 SAM보다 좋습니다.
- 람다 표현식 / 익명 함수 / 함수 레퍼런스 / 제한된 함수 레퍼런스 / 함수 타입으로
전달할 수 있습니다.
- 아규먼트 분해를 할 수 있습니다.
- 독립적으로 변경이 가능합니다.
## 아이템39 - 태그 클래스보다는 클래스 계층을 사용하라
 태그 클래스보다 sealed 클래스를 사용하여 표현하는 것이 좋습니다.
- 각 책임에 필요한 데이터와 파라미터만 갖습니다.
- sealed 한정자는 상속을 제한하므로 확장에 제약이 있습니다.

## 아이템40 - equals의 규약을 지켜라
 eqausls 규약을 지켜야 합니다.
- 동등성
- equals 규약
    - reflective
    - symmetric
    - transitive
    - consistent

## 아이템41 - hashCode의 규약을 지켜라
 hashCode 규약을 지켜야 합니다.
- 어떤 객체를 변경하지 않으면 hashCode를 여러번 호출해도 그 결과가 같아야 합니다.
- equals 결과 두객체가 같다면, hashCode 메쏘드의 결과값도 같아야 합니다.

## 아이템42 - compareTo의 규약을 지켜라
 compareTo 규약을 지켜야 합니다.
- 비대칭적 동작
- 연속적 동작
- 코넥스적 동작

## 아이템43 - API의 필수적이지 않는 부분을 확장 함수로 추출하라
 확장함수는 다음의 특성을 갖습니다.
- 확장 항수는 사용하기 전에 명시해야 합니다.
- 오버라이드를 사용할 수 없습니다.
- 이름 충돌시 우선 순위를 갖습니다.
- 확장 함수의 적용 기준은 클래스가 아닌 타입입니다.
- 확장 함수는 클래스 레퍼런스로 표현할 수 없습니다.

## 아이템44 - 멤버 확장 함수의 사용을 피하라
 멤버 확장 함수는 의미가 있는 경우가 아니면 사용하지 않는 것이 좋습니다.
- 확장 함수는 클래스 레퍼런스로 표현할 수 없습니다.
- 리시버가 혼동될 수 있습니다.
- 의도가 명확하지 않습니다.
