# 요약
## 6장 클래스 설계

## 아이템36 - 상속보다는 컴포지션을 사용하라
 컴포지션은 번거롭지만 일반적으로 상속을 사용하는 것보다 좋습니다. 리스코프 치환
원칙을 만족하는 경우에만 상속을 사용해야 합니다. 상속은 다음 문제를 가지고 있습니다.
- 클래스에만 적용할 수 있습니다.
- 클래스의 모두를 재사용합니다.
- 이해하기 어렵습니다.
- 캡슐화를 망가뜨립니다.

## 아이템37 - 데이터 집합 표현에 data 한정자를 사용하라
 데이타 묶음에 data class를 사용하는 것이 튜플보다 장점이 많습니다.
- 리턴 타입이 명확하고, 전달하기 쉽습니다.

## 아이템38 - 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라
 다른 언어에서 사용하는 경우가 아니라면 함수 타입을 사용하는 것이 SAM보다 좋습니다.
- 람다 표현식 / 익명 함수 / 함수 레퍼런스 / 제한된 함수 레퍼런스 / 함수 타입으로
전달할 수 있습니다.
- 아규먼트 분해를 할 수 있습니다.
- 독립적으로 변경이 가능합니다.

## 아이템39 - 태그 클래스보다는 클래스 계층을 사용하라
 태그 클래스보다 sealed 클래스를 사용하여 표현하는 것이 좋습니다.
- 각 책임에 필요한 데이터와 파라미터만 갖습니다.
- sealed 한정자는 상속을 제한하므로 확장에 제약이 있습니다.

## 아이템40 - equals의 규약을 지켜라
 eqausls 규약을 지켜야 합니다.
- 동등성
- equals 규약
    - reflective
    - symmetric
    - transitive
    - consistent

## 아이템41 - hashCode의 규약을 지켜라
 hashCode 규약을 지켜야 합니다.
- 어떤 객체를 변경하지 않으면 hashCode를 여러번 호출해도 그 결과가 같아야 합니다.
- equals 결과 두객체가 같다면, hashCode 메쏘드의 결과값도 같아야 합니다.

## 아이템42 - compareTo의 규약을 지켜라
 compareTo 규약을 지켜야 합니다.
- 비대칭적 동작
- 연속적 동작
- 코넥스적 동작

## 아이템43 - API의 필수적이지 않는 부분을 확장 함수로 추출하라
 확장함수는 다음의 특성을 갖습니다.
- 확장 항수는 사용하기 전에 명시해야 합니다.
- 오버라이드를 사용할 수 없습니다.
- 이름 충돌시 우선 순위를 갖습니다.
- 확장 함수의 적용 기준은 클래스가 아닌 타입입니다.
- 확장 함수는 클래스 레퍼런스로 표현할 수 없습니다.

## 아이템44 - 멤버 확장 함수의 사용을 피하라
 멤버 확장 함수는 의미가 있는 경우가 아니면 사용하지 않는 것이 좋습니다.
- 확장 함수는 클래스 레퍼런스로 표현할 수 없습니다.
- 리시버가 혼동될 수 있습니다.
- 의도가 명확하지 않습니다.

# 개인 독후감
## Charles
 원리보다 예시를 중심으로 기술되어 있다. 중요한 내용을 중요하지 않게 다루어서 좋다고
생각이 든다. 항상 기본이 중요하니까. 깊은 내용으로 들어갈 수도 있었지만 수위 조절을
잘 했고 가장 이펙티브 시리즈다운 스타일이었다. 책 전반에 이 기조를 유지했다면 완성도
높은 책이 되었을 것 같다.

## Olive
이번 장에서는, 최근 회사 업무를 진행하면서 고민하던 포인트들에 대해서 한번더 물음과 짧은 인사이트를 전달해줘서 좋은 것 같다. (상속을 언제 사용해야하는지,
태그 클래스의 문제점 등) 뒷 부분에 나오는 `equals`, `hashCode`, `compareTo` 등의 설계 규약과 관련된 부분은 거의 대부분의 내용이 이펙티브 자바와 동일했는데, `data` 클래스의
`equals` 및 `hashCode`를 코틀린에서 섬세하게 구현한 부분에 대해서는 굉장히 인상깊었다.

## Kuma
지금까지 내가 작성해온 모든 작업의 클래스 설계에 대해 다시 고민하게 만들어준 장이었다. 기능을 추가하다 보면 기존 의도와 다른 방향으로 망가져 버리게 되며
나중에 관리가 힘들게 되는 경향이 있었다. 코틀린에선 기존 자바의 기능들과 더불어 data 한정자, sealed 클래스 등 더 많은 옵션을 제공해주는 게 좋았다.
자바보다 더 섬세한 부분을 신경 쓴 언어가 코틀린이 아닐까 생각이 든다.

# 토론 주제
## 클래스 설계에 유용한 방식은 또 어떤 것들이 있을까?

## 다중 상속을 위해 추상 클래스 대신 인터페이스를 통해 특정 프로퍼티를 강제하는 설계 방식은 타당한가?
