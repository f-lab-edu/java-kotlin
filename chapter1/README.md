# 요약
## 가변성 제한
- var → val 사용
- mutable보다 읽기 전용 컬렉션을 사용
- 변이지점은 신중하게 설정
- immutable 객체 사용해 가변성을 억제하거나 copy로 가변적 객체를 복사

## 변수의 스코프 최소화
- 전역 변수가 아닌 지역 변수 사용
- 사용되는 변수의 스코프를 최대한 줄여 범위 최소화
- 변수가 처음 생성될 때 초기화하는 걸 추천
- 구조분해 선언
- 변수 캡쳐링 주의
[https://velog.io/@kmdngmn/Java-람다-캡처링-Lambda-Capturing-Java-8](https://velog.io/@kmdngmn/Java-%EB%9E%8C%EB%8B%A4-%EC%BA%A1%EC%B2%98%EB%A7%81-Lambda-Capturing-Java-8)

## 플랫폼 타입 사용 자제
- 플랫폼 타입 : 다른 언어에서 넘어온 타입(ex. Java → Generic)으로 nullable 여부를 파악할 수 없는 타입을 의미
- not null 표시 !!
- 연결하는 언어에서 null 여부를 표기하는 어노테이션을 사용해줘야 한다.

## Inferred 타입으로 리턴 x
- 리턴 타입을 명시
- 지정한 타입은 신중하게 후관리 필요

## 예외 활용
- 아규먼트 - require
제한 또는 valid 체크
: 조건을 확인해 IllegalArgumentException을 던진다
: 앞부분에서 코드를 쉽게 확인 (문서에 별도 표시)

- 상태 - check
: 조건을 확인해 IllegalStateException을 던진다
: require 뒤에 사용

- 참/거짓 - assert 계열
JVM에서만 활성화
코드를 자체 점검하여 테스트에 유용
어느 지점에서 예외가 발생하는지 확인 가능
스마트 캐스팅 활용

- 그외에도 throws로 예외 호출

## 사용자 정의 오류 대신 표준 오류 사용
- 더 알려진 표준 오류를 사용해서 타 개발자가 더 빠르게 API에 적응하도록 돕는다

## 결과 부족 시 null과 Failure 사용
- 예상치 못한 일을 처리할 때 예외를 throw 하거나 null/sealed class를 사용
- 예외는 코틀린에서 unchecked로 분류돼 처리하기 어려움
- null과 sealed class는 오류 표현 뿐만 아니라 오류 처리도 간단히 가능
- sealed class는 예외 발생 시 추가 정보를 넘길 때 사용하고 null은 전달할 정보가 없을 때 사용
- 대신 그냥 null 반환보다 getOrNull 같이 null이 반환될 수 있다는 정보를 표시하는 게 좋음

## 적절한 null 처리
1. ? : 스마트 캐스팅
- 스마트캐스팅 또는 Elvis 연산자로 nullable 처리

Elvis 연산자?
`?:`로 표현하며, `?:`의 왼쪽 객체가 non-null이면 그 객체의 값이 리턴되고, null이라면 `?:`
의 오른쪽 값을 리턴
출처 : [https://codechacha.com/ko/kotlin-elvis-operation/](https://codechacha.com/ko/kotlin-elvis-operation/)

- 방어적 프로그래밍 vs 공격적 프로그래밍

throws
- 오류를 발생시켜 null이 있는 곳을 알려줄 수 있음

nullable 안 나오도록 리팩터링
- not null assertion(!!)의 경우 오남용의 여지가 있으니 사용에 주의
- 다른 null 방식을 사용
- null 보다는 빈 제네릴 객체를 사용
- lateinit을 이용해 초기화를 늦추는 방식

var, null, getter, setter 사용 안 됨
null 허용 표시 없이 null 사용 방지 가능

## use를 사용해 리소스 닫기
- 자바에서 Closeable, AutoCloseable 인터페이스를 구현해 사용하던 close() 대신 코틀린에서는 use로 사용

## 단위 테스트를 만들어라
- 단위 테스트는 빠르고 회귀적으로 작성된 코드의 오류를 파악할 수 있어 유용한 도구
- TDD 방식으로 테스트를 먼저 작성하고 코드를 작성하는 방법도 있다
- 대신 단위 테스트를 작성하는데 많은 리소스와 작성 방식에 주의를 기울여야 한다.

# 개인 독후감
## Charles
 이번 장은 안정성을 다루고 있다. 가장 기본적인 주제여서 코틀린에만 국한된
내용보다는 모든 프로그래밍 언어에 적용될 만한 내용으로 채워져있다. 개인적으로
불변성 장이 가장 좋았다. 불변성 부분에서 읽기 전용, 변경 가능 지점, 불변성을
구분하여 다룬 점이 마음에 들었고, 다른 장에 비해 깊은 주제였기 때문이다.

 반면에 이 챕터의 제목가 *****안정성**이라는 점을 고려할 때 다른 주제들이 기본기에
해당하는 내용들을 담긴 것이 충분히 이해되지만 거꾸로 불변성이라는 주제가 요즘에는
기본기에 해당한다니 좀 놀라웠던 부분이기도 하다.

 내가 불변성의 효용을 느낀 것은 병렬처리에 사용할 때인데, 책에서 성능 관점에서
불변 객체를 다루지 않은 점은 아쉽다. 그리고 책의 예제가 최선(Best practice)가
아니라 설명하고 있는 주제만 보여주는 수준이라는 점이 아쉽니다. 책에서 다루는
개념이 단순하고 기본적인 내용이라 그런 것 같다.

## Kuma
 1장은 아무래도 기본적인 내용을 다루기에 이견이 거의 없는 내용들이라고 봤다.
자바에도 적용이 될 수 있는 부분이라 자바를 사용했던 경험들을 꺼내
보며 내용을 이해하려 했다. 그래서인지, 책을 읽다 이해가 안 되는 이론을 맞닥뜨리면 
코틀린 키워드를 빼고 검색을 했다. 코틀린에 대해 배우려다 오히려 프로그래밍의 베이스 지식까지
훑게 되면서 다시 공부하게 되는 계기를 줬다.

 코틀린의 장점 중 하나인 null safety 관련 내용이 매우 많이 나온다. 
null이 예상치 못한 오류를 발생시키기에 이를 막는 게 안정성을 보장해준다는 저자의 의미를
담은 것 같다.

## Olive
책을 읽으면서 이펙티브 자바와 중복된 아이템들도 여러개 있었고, 전반적으로 코틀린에 특화된 어떠한 개념을 이야기한다기 보다는,
전반적으로 여러 프로그래밍 언어를 이용해서 개발할 때, 범용성있게 적용될 수 있는 주제들이 주를 이룬 것 같은 느낌을 많이 받았다.

다른 내용들도 물론 좋았지만, 불변성에 대한 부분 그리고 `null`에 대한 부분이 가장 기억에 남는 것 같다. 가변성의 경우 이펙티브 자바 "아이템 17. 변경 가능성을 최소화하라"에서 이야기하고 있는 부분과
크게 다르지 않지만 리마인드 차원에서 한번더 돌아볼 수 있어서인것 같고, `null`의 경우는 스터디 이후에 가장 기억에 남게되었는데, 독후감을 쓰는 시점이 스터디 이후라 잠깐 언급하자면, 스터디를 진행하면서 `null`을 어떻게 해석하고 사용할 것인지에 대한 논의가 이루어졌었는데,
Charles께서 말씀해주신 프로그래밍 언어적 측면에서 `null`이 갖는 의미와, `null`을 어떻게 해석하고 사용하는 것이 좋을지에 대한 논의를 통해 `null`의 존재 의미와 활용에 대해서 다시 한번쯤 생각해 볼 수 있던 좋은 기회가 된 것 같다.

## Taek
F-Lab 멘토링을 받으면서 immutable, mutable에 대해서 인지는 하고 있었지만 실제로 개발할 때 크게 신경쓰지 못한 포인트였었다. 하지만 1장에서부터 Immutable 객체를 사용하면 좋은 점들이 대해서 안내하여 확실하게 인지하는 계기가 되었다. 그 밖에도 코틀린에 한정된 것이 아니라 전체적인 프로그래밍 언어 베이스로 개발을 진행할 때 기본적으로 지키면 좋은 것들에 대한 안내가 나와있다. 잠깐 `코루틴`에 대한 언급이 있어서 중요한 것 같아 찾아봤더니 동시성 관련 내용이였고 관련해서 추후 더 상세하게 학습을 예정이다.

---

# 토론 주제
### 논점 1. 사용자 정의 오류와 표준 오류              
두 오류를 사용하게 되는 상황은 어떤 때인가?

엔지니어링이 강한 회사(또는 스타트업, 신규 사업)은 공격적 코딩이 주가 되어 
표준 오류를 사용하게 된다.
서비스 회사의 경우 방어적 코딩을 중시해 사용자 정의 오류를 사용하게 된다.

예외 처리의 경우 되도록 처리가 되지 않는 상황을 만드는 게 좋다.
이유는 top down 구조에서 C언어의 goto 예외 처리와 관련이 있다.

<br>

### 논점 2. 단위 테스트               
단위 테스트를 어떻게 사용해야 할까?

단위 테스트는 너무 광범위한 내용을 다루므로 현재는 넘어가는 걸로 결정함
대신 단위 테스트를 작성할 때는 "무엇"을 테스트 해야 하는지 명확하게 인식하고 작성해야 한다.
안 그러면 작성 코드량만 불어나며 비효율적인 작업이 된다.

<br>

### 논점 3. immutable collection              
불변 객체에 값을 더할 때 새로 객체를 생성하며 성능 상 불이익이 발생하는가?

copy 대신 플러스로 값을 더해 새로운 객체를 만들 면 불이익은 발생하지 않는다.

<br>

### 논점 4. immutable                  
객체지향적인 언어는 상태와 행위를 포함한다. 그런데 불변 객체는 상태가 없다. 그렇다면 이 상황에서 불변 객체는 과연 객체지향적인 것인가?

해당 논점은 각자 좀 더 생각해보기로 했음.

<br>

### 논점 5. null의 해석                
개발자마다 null의 의미 부여가 달라 생기는 문제점?

null을 아예 안 쓰는 방법 또는 null을 잘 활용하는 방법을 고려할 수 있다.
null을 사용하지 않으면 안전하지만 그만큼 코드가 불어나 가독성과 작성 시간이 길어질 수 있다. null을 활용하면 편하긴 하지만 그만큼 남용될 가능성이 있다.
